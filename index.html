<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NBA Last 10 Games Prototype</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: #050816;
      color: #f9fafb;
    }

    .app {
      display: flex;
      min-height: 100vh;
    }

    .sidebar {
      width: 300px;
      border-right: 1px solid rgba(148, 163, 184, 0.4);
      padding: 16px;
      background: radial-gradient(circle at top left, #0f172a, #020617);
    }

    .sidebar h1 {
      font-size: 18px;
      margin-bottom: 8px;
    }

    .sidebar small {
      display: block;
      margin-bottom: 8px;
      color: #9ca3af;
      font-size: 12px;
    }

    .sidebar .env-warning {
      font-size: 11px;
      color: #fecaca;
      background: rgba(127, 29, 29, 0.3);
      border-radius: 8px;
      padding: 6px 8px;
      margin-bottom: 8px;
      border: 1px solid rgba(248, 113, 113, 0.6);
    }

    .games-list {
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      padding-right: 4px;
    }

    .game-item {
      border-radius: 10px;
      padding: 10px 12px;
      margin-bottom: 8px;
      cursor: pointer;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid transparent;
      transition: background 0.15s ease, border-color 0.15s ease, transform 0.1s ease;
    }

    .game-item:hover {
      background: rgba(30, 64, 175, 0.6);
      border-color: rgba(129, 140, 248, 0.8);
      transform: translateY(-1px);
    }

    .game-item.active {
      background: rgba(30, 64, 175, 0.9);
      border-color: rgba(191, 219, 254, 0.9);
    }

    .game-teams {
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      margin-bottom: 4px;
    }

    .game-meta {
      font-size: 11px;
      color: #9ca3af;
    }

    .main {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
    }

    .placeholder {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #9ca3af;
      font-size: 14px;
      text-align: center;
      padding: 0 16px;
    }

    .game-header {
      margin-bottom: 16px;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
    }

    .game-header h2 {
      font-size: 18px;
      font-weight: 600;
    }

    .teams-container {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }

    .team-panel {
      flex: 1 1 420px;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.9));
      border-radius: 14px;
      border: 1px solid rgba(51, 65, 85, 0.9);
      padding: 12px;
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.8);
    }

    .team-panel h3 {
      font-size: 15px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .players-list {
      max-height: calc(100vh - 180px);
      overflow-y: auto;
      padding-right: 6px;
    }

    .player-card {
      border-radius: 12px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      padding: 8px 10px;
      margin-bottom: 8px;
      background: rgba(15, 23, 42, 0.9);
    }

    .player-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 6px;
      gap: 6px;
    }

    .player-name {
      font-size: 13px;
      font-weight: 600;
    }

    .player-meta {
      font-size: 11px;
      color: #9ca3af;
    }

    .player-content {
      display: flex;
      gap: 10px;
      align-items: stretch;
    }

    .stat-grid-wrapper {
      flex: 1 1 auto;
    }

    .player-summary {
      flex: 0 0 160px;
      background: rgba(15, 23, 42, 1);
      border-radius: 10px;
      border: 1px solid rgba(59, 130, 246, 0.8);
      padding: 6px 8px;
      font-size: 11px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .summary-title {
      font-size: 11px;
      font-weight: 700;
      color: #bfdbfe;
      margin-bottom: 2px;
    }

    .summary-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 4px;
    }

    .summary-label {
      font-weight: 600;
      color: #9ca3af;
      white-space: nowrap;
    }

    .summary-value {
      font-weight: 700;
      color: #f9fafb;
      font-size: 11px;
      text-align: right;
      white-space: nowrap;
    }

    .stat-grid {
      display: flex;
      flex-direction: column;
      gap: 1px;
      font-size: 10px;
      overflow-x: auto;
    }

    .stat-row {
      display: grid;
      grid-template-columns: 30px repeat(10, minmax(18px, 1fr));
      gap: 1px;
      align-items: center;
    }

    .stat-row--dates {
      margin-bottom: 2px;
    }

    .stat-label {
      font-weight: 600;
      text-align: center;
      color: #9ca3af;
      font-size: 9px;
    }

    .stat-label--date {
      font-size: 9px;
      color: #6b7280;
    }

    .stat-cell {
      text-align: center;
      padding: 1px 0;
      border-radius: 3px;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(31, 41, 55, 0.9);
      min-width: 18px;
    }

    .stat-cell--date {
      font-size: 9px;
      color: #9ca3af;
      border-style: dotted;
    }

    .stat-cell--empty {
      opacity: 0.4;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      padding: 2px 8px;
      font-size: 11px;
      color: #9ca3af;
      gap: 4px;
    }

    .tag-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #22c55e;
    }

    .error {
      color: #fecaca;
      font-size: 13px;
      margin-top: 8px;
    }

    .loading {
      font-size: 12px;
      color: #9ca3af;
      margin-top: 4px;
    }

    @media (max-width: 900px) {
      .app {
        flex-direction: column;
      }
      .sidebar {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid rgba(148, 163, 184, 0.4);
      }
      .player-content {
        flex-direction: column;
      }
      .player-summary {
        flex: 1 1 auto;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <h1>NBA Matchups</h1>
      <small>Click a matchup to load players and last 10 games for each team.</small>
      <div id="env-warning" class="env-warning" style="display:none">
        You're running from <strong>file://</strong> (origin <code>null</code>). NBA JSON endpoints don't allow this because of CORS.
        To see REAL data, either:
        <ul>
          <li>Serve this file from a local web server (e.g. <code>python -m http.server 8080</code>), and/or</li>
          <li>Configure <code>NBA_PROXY_PREFIX</code> to point at your own CORS proxy.</li>
        </ul>
      </div>
      <div id="sidebar-status" class="loading">Loading today's games…</div>
      <div id="games-list" class="games-list"></div>
    </aside>

    <main class="main">
      <div id="game-detail" class="placeholder">
        Choose a matchup on the left to see players and last 10-game stats.<br /><br />
        Each player card shows a compact 10-game grid with game dates on top, and on the right a clear LOW (non-zero) and AVG P/R/A box.
      </div>
    </main>
  </div>

  <script>
    // === CONFIG ===
    const SCOREBOARD_URL = 'https://cdn.nba.com/static/json/liveData/scoreboard/todaysScoreboard_00.json';
    const SCHEDULE_URL = 'https://cdn.nba.com/static/json/staticData/scheduleLeagueV2_1.json';
    const BOXSCORE_BASE_URL = 'https://cdn.nba.com/static/json/liveData/boxscore/boxscore_';
    const GAMES_TO_LOOK_BACK = 10;

    // When deployed on Vercel, this points to your serverless proxy function.
    const NBA_PROXY_PREFIX = '/api/nba-proxy?url=';

    const appState = {
      scoreboard: null,
      scheduleGames: null,
      activeGameId: null,
      boxscoreCache: {}
    };

    // === Helper: basic JSON fetch with defensive error handling ===
    async function fetchJson(url) {
      const finalUrl = NBA_PROXY_PREFIX
        ? NBA_PROXY_PREFIX + encodeURIComponent(url)
        : url;
      try {
        const res = await fetch(finalUrl);
        if (!res.ok) {
          console.error('Request failed:', finalUrl, res.status, res.statusText);
          return null;
        }
        return await res.json();
      } catch (err) {
        console.error('Fetch failed for', finalUrl, err);
        return null; // prevent uncaught TypeError: Failed to fetch
      }
    }

    async function loadScoreboard() {
      if (appState.scoreboard) return appState.scoreboard;
      const data = await fetchJson(SCOREBOARD_URL);
      if (!data) return null;
      appState.scoreboard = data.scoreboard || data;
      return appState.scoreboard;
    }

    async function loadSchedule() {
      if (appState.scheduleGames) return appState.scheduleGames;
      const data = await fetchJson(SCHEDULE_URL);
      if (!data) return [];
      const league = data.leagueSchedule || data;
      const gameDates = league.gameDates || [];
      const flat = [];
      gameDates.forEach(dateEntry => {
        const dateLabel = dateEntry.gameDate;
        (dateEntry.games || []).forEach(game => {
          flat.push({
            ...game,
            scheduleGameDate: dateLabel
          });
        });
      });
      appState.scheduleGames = flat;
      return flat;
    }

    async function getBoxscore(gameId) {
      if (appState.boxscoreCache[gameId]) return appState.boxscoreCache[gameId];
      const url = BOXSCORE_BASE_URL + gameId + '.json';
      const data = await fetchJson(url);
      if (!data) return null;
      appState.boxscoreCache[gameId] = data;
      return data;
    }

    function renderGamesList(scoreboard) {
      const listEl = document.getElementById('games-list');
      const statusEl = document.getElementById('sidebar-status');
      listEl.innerHTML = '';

      const games = (scoreboard && scoreboard.games) || [];
      if (!games.length) {
        statusEl.textContent = 'No games found for today (or scoreboard unavailable).';
        return;
      }

      statusEl.textContent = `Game date: ${scoreboard.gameDate || ''}`;

      games.forEach(game => {
        const item = document.createElement('div');
        item.className = 'game-item';
        item.dataset.gameId = game.gameId;

        const teams = document.createElement('div');
        teams.className = 'game-teams';
        teams.innerHTML = `
          <span>${game.awayTeam.teamTricode}</span>
          <span>@</span>
          <span>${game.homeTeam.teamTricode}</span>
        `;

        const meta = document.createElement('div');
        meta.className = 'game-meta';
        const statusText = game.gameStatusText || (game.gameStatus === 1 ? 'Scheduled' : 'In Progress');
        meta.textContent = `${statusText}`;

        item.appendChild(teams);
        item.appendChild(meta);

        item.addEventListener('click', () => {
          document.querySelectorAll('.game-item').forEach(el => el.classList.remove('active'));
          item.classList.add('active');
          loadGameDetail(game).catch(err => {
            console.error(err);
            renderError('Failed to load game detail: ' + err.message);
          });
        });

        listEl.appendChild(item);
      });
    }

    function renderError(message) {
      const container = document.getElementById('game-detail');
      container.className = '';
      container.innerHTML = `<div class="error">${message}</div>`;
    }

    function minNonNull(values) {
      const filtered = values.filter(v => v !== null && v !== undefined);
      if (!filtered.length) return null;
      return Math.min(...filtered);
    }

    // Prefer lowest NON-ZERO value; only use 0 if that's all there is.
    function minNonZeroPreferred(values) {
      const filtered = values.filter(v => v !== null && v !== undefined);
      if (!filtered.length) return { low: null, lowNonZero: null };
      const nonZero = filtered.filter(v => v !== 0);
      const lowNonZero = nonZero.length ? Math.min(...nonZero) : null;
      const low = lowNonZero !== null ? lowNonZero : Math.min(...filtered);
      return { low, lowNonZero };
    }

    function avgNonNull(values) {
      const filtered = values.filter(v => v !== null && v !== undefined);
      if (!filtered.length) return null;
      const sum = filtered.reduce((acc, v) => acc + v, 0);
      return Number((sum / filtered.length).toFixed(1));
    }

    function formatScheduleDate(raw) {
      if (!raw) return null;
      // Expecting YYYY-MM-DD, keep MM-DD for compact view
      if (raw.length >= 10) {
        return raw.slice(5, 10);
      }
      return raw;
    }

    function createDateRow(dates) {
      const row = document.createElement('div');
      row.className = 'stat-row stat-row--dates';

      const labelEl = document.createElement('div');
      labelEl.className = 'stat-label stat-label--date';
      labelEl.textContent = 'DATE';
      row.appendChild(labelEl);

      const totalSlots = GAMES_TO_LOOK_BACK;
      for (let i = 0; i < totalSlots; i++) {
        const cell = document.createElement('div');
        cell.className = 'stat-cell stat-cell--date';
        const val = dates[i];
        cell.textContent = val || '-';
        row.appendChild(cell);
      }

      return row;
    }

    function createStatRow(label, values) {
      const row = document.createElement('div');
      row.className = 'stat-row';

      const labelEl = document.createElement('div');
      labelEl.className = 'stat-label';
      labelEl.textContent = label;
      row.appendChild(labelEl);

      const totalSlots = GAMES_TO_LOOK_BACK;
      for (let i = 0; i < totalSlots; i++) {
        const cell = document.createElement('div');
        cell.className = 'stat-cell';
        const val = values[i];
        if (val === null || val === undefined) {
          cell.classList.add('stat-cell--empty');
          cell.textContent = '-';
        } else {
          cell.textContent = val;
        }
        row.appendChild(cell);
      }

      return row;
    }

    function buildPlayerCard(player, teamId, historyStats) {
      const card = document.createElement('div');
      card.className = 'player-card';

      const header = document.createElement('div');
      header.className = 'player-header';

      const nameEl = document.createElement('div');
      nameEl.className = 'player-name';
      nameEl.textContent = `${player.firstName || ''} ${player.familyName || ''}`.trim() || player.name;

      const metaEl = document.createElement('div');
      metaEl.className = 'player-meta';
      metaEl.textContent = player.position ? player.position.toUpperCase() : '';

      header.appendChild(nameEl);
      header.appendChild(metaEl);

      const content = document.createElement('div');
      content.className = 'player-content';

      const gridWrapper = document.createElement('div');
      gridWrapper.className = 'stat-grid-wrapper';

      const statGrid = document.createElement('div');
      statGrid.className = 'stat-grid';

      const dateRow = createDateRow(historyStats.dates || []);
      const ptsRow = createStatRow('PTS', historyStats.points);
      const astRow = createStatRow('AST', historyStats.assists);
      const rebRow = createStatRow('REB', historyStats.rebounds);

      statGrid.appendChild(dateRow);
      statGrid.appendChild(ptsRow);
      statGrid.appendChild(astRow);
      statGrid.appendChild(rebRow);

      gridWrapper.appendChild(statGrid);

      const summary = document.createElement('div');
      summary.className = 'player-summary';

      const summaryTitle = document.createElement('div');
      summaryTitle.className = 'summary-title';
      summaryTitle.textContent = 'Key Prop Stats';

      const lowRow = document.createElement('div');
      lowRow.className = 'summary-row';
      const lowLabel = document.createElement('div');
      lowLabel.className = 'summary-label';
      lowLabel.textContent = 'LOW (NZ)';

      const lowVal = document.createElement('div');
      lowVal.className = 'summary-value';
      const lowP = historyStats.minPointsNonZero ?? historyStats.minPoints;
      const lowR = historyStats.minReboundsNonZero ?? historyStats.minRebounds;
      const lowA = historyStats.minAssistsNonZero ?? historyStats.minAssists;
      lowVal.textContent = `P:${lowP ?? '-'} R:${lowR ?? '-'} A:${lowA ?? '-'}`;

      lowRow.appendChild(lowLabel);
      lowRow.appendChild(lowVal);

      const avgRow = document.createElement('div');
      avgRow.className = 'summary-row';
      const avgLabel = document.createElement('div');
      avgLabel.className = 'summary-label';
      avgLabel.textContent = 'AVG';

      const avgVal = document.createElement('div');
      avgVal.className = 'summary-value';
      avgVal.textContent = `P:${historyStats.avgPoints ?? '-'} R:${historyStats.avgRebounds ?? '-'} A:${historyStats.avgAssists ?? '-'}`;

      avgRow.appendChild(avgLabel);
      avgRow.appendChild(avgVal);

      summary.appendChild(summaryTitle);
      summary.appendChild(lowRow);
      summary.appendChild(avgRow);

      content.appendChild(gridWrapper);
      content.appendChild(summary);

      card.appendChild(header);
      card.appendChild(content);

      return card;
    }

    function computePlayerHistory(playerId, teamId, teamHistory) {
      const points = [];
      const assists = [];
      const rebounds = [];
      const dates = [];

      teamHistory.boxscores.forEach((bs, idx) => {
        if (!bs) {
          points.push(null);
          assists.push(null);
          rebounds.push(null);
          dates.push(null);
          return;
        }
        const game = bs.game || bs;
        let teamObj = null;
        if (String(game.homeTeam.teamId) === String(teamId)) {
          teamObj = game.homeTeam;
        } else if (String(game.awayTeam.teamId) === String(teamId)) {
          teamObj = game.awayTeam;
        }

        const gameInfo = teamHistory.games[idx];
        const rawDate = gameInfo ? (gameInfo.gameDate || gameInfo.scheduleGameDate) : null;
        dates.push(formatScheduleDate(rawDate));

        if (!teamObj || !teamObj.players) {
          points.push(null);
          assists.push(null);
          rebounds.push(null);
          return;
        }
        const p = teamObj.players.find(pl => String(pl.personId) === String(playerId));
        if (!p || !p.statistics) {
          points.push(null);
          assists.push(null);
          rebounds.push(null);
        } else {
          points.push(p.statistics.points ?? null);
          assists.push(p.statistics.assists ?? null);
          rebounds.push(p.statistics.reboundsTotal ?? null);
        }
      });

      const { low: minPoints, lowNonZero: minPointsNonZero } = minNonZeroPreferred(points);
      const { low: minAssists, lowNonZero: minAssistsNonZero } = minNonZeroPreferred(assists);
      const { low: minRebounds, lowNonZero: minReboundsNonZero } = minNonZeroPreferred(rebounds);

      const avgPoints = avgNonNull(points);
      const avgAssists = avgNonNull(assists);
      const avgRebounds = avgNonNull(rebounds);

      return {
        points,
        assists,
        rebounds,
        dates,
        minPoints,
        minAssists,
        minRebounds,
        minPointsNonZero,
        minAssistsNonZero,
        minReboundsNonZero,
        avgPoints,
        avgAssists,
        avgRebounds
      };
    }

    function getLastNGamesForTeam(scheduleGames, teamId, currentGameId, n) {
      const teamGames = scheduleGames.filter(g => {
        const homeId = g.homeTeam && g.homeTeam.teamId;
        const awayId = g.awayTeam && g.awayTeam.teamId;
        return String(homeId) === String(teamId) || String(awayId) === String(teamId);
      });

      const idx = teamGames.findIndex(g => String(g.gameId) === String(currentGameId));
      const endIdx = idx === -1 ? teamGames.length : idx;
      const startIdx = Math.max(0, endIdx - n);
      const slice = teamGames.slice(startIdx, endIdx);
      return slice.reverse();
    }

    async function buildTeamHistory(teamId, currentGameId) {
      const scheduleGames = await loadSchedule();
      if (!scheduleGames.length) {
        return { games: [], boxscores: [] };
      }
      const lastGames = getLastNGamesForTeam(scheduleGames, teamId, currentGameId, GAMES_TO_LOOK_BACK);
      const boxscores = await Promise.all(lastGames.map(g => getBoxscore(g.gameId)));
      return { games: lastGames, boxscores };
    }

    async function loadGameDetail(game) {
      appState.activeGameId = game.gameId;
      const container = document.getElementById('game-detail');
      container.className = '';
      container.innerHTML = '<div class="loading">Loading game details and last 10 games…</div>';

      try {
        const [currentBoxscore, homeHistory, awayHistory] = await Promise.all([
          getBoxscore(game.gameId),
          buildTeamHistory(game.homeTeam.teamId, game.gameId),
          buildTeamHistory(game.awayTeam.teamId, game.gameId)
        ]);

        if (!currentBoxscore || !homeHistory || !awayHistory) {
          renderError('Could not load boxscores or team histories. This is almost always a CORS / proxy issue.');
          return;
        }

        const boxGame = currentBoxscore.game || currentBoxscore;
        const homeTeam = boxGame.homeTeam;
        const awayTeam = boxGame.awayTeam;

        const wrapper = document.createElement('div');

        const header = document.createElement('div');
        header.className = 'game-header';
        const title = document.createElement('h2');
        title.textContent = `${awayTeam.teamTricode} @ ${homeTeam.teamTricode}`;

        const tag = document.createElement('div');
        tag.className = 'tag';
        const dot = document.createElement('span');
        dot.className = 'tag-dot';
        const statusText = game.gameStatusText || (game.gameStatus === 1 ? 'Scheduled' : 'In Progress');
        const tagText = document.createElement('span');
        tagText.textContent = statusText;
        tag.appendChild(dot);
        tag.appendChild(tagText);

        header.appendChild(title);
        header.appendChild(tag);

        const teamsContainer = document.createElement('div');
        teamsContainer.className = 'teams-container';

        function buildTeamPanel(team, history, label) {
          const panel = document.createElement('div');
          panel.className = 'team-panel';
          const title = document.createElement('h3');
          title.textContent = `${team.teamCity} ${team.teamName} (${label})`;
          panel.appendChild(title);

          const playersList = document.createElement('div');
          playersList.className = 'players-list';

          const players = (team.players || []).slice();
          players.sort((a, b) => {
            const aStarter = a.starter === '1' ? 1 : 0;
            const bStarter = b.starter === '1' ? 1 : 0;
            if (aStarter !== bStarter) return bStarter - aStarter;
            return (b.statistics?.points || 0) - (a.statistics?.points || 0);
          });

          players.forEach(player => {
            const hist = computePlayerHistory(player.personId, team.teamId, history);
            const card = buildPlayerCard(player, team.teamId, hist);
            playersList.appendChild(card);
          });

          panel.appendChild(playersList);
          return panel;
        }

        const homePanel = buildTeamPanel(homeTeam, homeHistory, 'HOME');
        const awayPanel = buildTeamPanel(awayTeam, awayHistory, 'AWAY');

        teamsContainer.appendChild(homePanel);
        teamsContainer.appendChild(awayPanel);

        wrapper.appendChild(header);
        wrapper.appendChild(teamsContainer);

        container.innerHTML = '';
        container.appendChild(wrapper);
      } catch (err) {
        console.error(err);
        renderError('Failed to load game or history. Check your CORS proxy configuration (NBA_PROXY_PREFIX) or run this through a backend.');
      }
    }

    // === Simple test cases for helper functions ===
    function runTests() {
      console.group('Helper tests');

      console.log('minNonNull tests');
      console.log('Expect 2:', minNonNull([3, 5, null, 2]));
      console.log('Expect null:', minNonNull([null, undefined]));
      console.log('Expect 0:', minNonNull([0, 4, 7]));

      console.log('getLastNGamesForTeam tests');
      const fakeSchedule = [
        { gameId: 'A', homeTeam: { teamId: 1 }, awayTeam: { teamId: 2 } },
        { gameId: 'B', homeTeam: { teamId: 3 }, awayTeam: { teamId: 1 } },
        { gameId: 'C', homeTeam: { teamId: 4 }, awayTeam: { teamId: 1 } },
        { gameId: 'D', homeTeam: { teamId: 1 }, awayTeam: { teamId: 5 } }
      ];
      const last2BeforeC = getLastNGamesForTeam(fakeSchedule, 1, 'C', 2);
      console.log('Expect [B, A]:', last2BeforeC.map(g => g.gameId));

      console.log('minNonZeroPreferred tests');
      console.log('Expect low=2, lowNonZero=2:', minNonZeroPreferred([0, 2, 5, 0, 7]));
      console.log('Expect low=5, lowNonZero=5 (no zeros):', minNonZeroPreferred([5, 9, 12]));
      console.log('Expect low=0, lowNonZero=null (only zeros):', minNonZeroPreferred([0, 0]));

      console.log('avgNonNull tests');
      console.log('Expect 5.0:', avgNonNull([4, 6]));
      console.log('Expect 3.3:', avgNonNull([3, 3, 4]));
      console.log('Expect null:', avgNonNull([null, undefined]));

      console.log('formatScheduleDate tests');
      console.log('Expect 11-21:', formatScheduleDate('2024-11-21'));
      console.log('Expect null:', formatScheduleDate(null));

      console.groupEnd();
    }

    async function init() {
      const envWarningEl = document.getElementById('env-warning');
      if (window.location.protocol === 'file:') {
        envWarningEl.style.display = 'block';
      }

      try {
        const scoreboard = await loadScoreboard();
        if (!scoreboard) {
          const statusEl = document.getElementById('sidebar-status');
          statusEl.textContent = 'Failed to load today\'s games. This is almost certainly CORS (no proxy) or network.';
          return;
        }
        renderGamesList(scoreboard);
      } catch (err) {
        console.error(err);
        const statusEl = document.getElementById('sidebar-status');
        statusEl.textContent = 'Unexpected error while loading games.';
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      runTests();
      init();
    });
  </script>
</body>
</html>
